<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>A Few Good Patterns</title>
</head>
<body>
  <h1>A Few Good Patterns</h1>  

  <section>
    <h2>Multiple Pointers</h2>
    <p>This will be handy on a case by case basis, so just be aware of the strategy.</p>
    <p>The concept is to eliminate an O(n^2) nested loop brute force operation, <br> 
    by using <em>Multiple Pointers</em>.</p>
    <p>What you do, should your solution space warrant it, is to set a 
      pointer, usually to the front, and a second at the end fo an array, 
      <em>Linked list, collection...</em>
      and then do your calculations to single in on your target. 
    </p>
    <p>That seems like a very obscure definition. <br>
     When the opportunity arises, we will revist with a real world example.
    </p>
    <p><strong>LeetCodeSession 3-29-23</strong><br>
     the goal was to find a maximum area between two bars on a graph. 
     This is a good example, although I can't imagine where it would be handy...
    </p>
  </section>
  <section>
    <h2>Sliding Window</h2>
    <p>
      Technically another Multiple Pointers pattern, but focused on a contiguous range rather than 
      a shrinking set.. [?] Does that even make sense? 
    </p>
  </section>
  <section>
    <h2>Divide and Conquer</h2>
    <p>The classic example is <em>Binary Search</em>. <br>
      Basically, seperate the number of things under consideration in half, <br> 
      yielding O(logN) rather than O(n). 
    </p>
  </section>

  <script>
      
    function isAlphaNumeric(ch){
      let c = ch.charCodeAt(0);
      return !(!(c > 47 && c < 58) && 
               !(c > 64 && c < 91) &&
               !(c > 96 && c < 123))
    }

    function charCount(str, lower=true){
      let obj = {}
      for(let c of str){
        if(isAlphaNumeric(c)){
          if(lower) c = c.toLowerCase();
          obj[c] = ++obj[c] || 1;
        } 
      }
      return obj
    }

function freq(arr){
  let obj = {}
  for(let item of arr){
     obj[item] = ++obj[item] || 1;
    } 
    return obj
}

// Useful for numbers, or letters... 
// Needs expansion for general use.

// the Transformation callback [ tx ] is 
// availible for comparison of two arrays
// with a mutation test. See Example Below.
function sameFrequency(arr1, arr2, tx=(v)=>v){
  if(arr1.length != arr2.length) return false;

  let obj1 = freq(arr1);
  let obj2 = freq(arr2);

  for(let u in obj1){
    if(!(obj1[u] == obj2[tx(u)])){
      return false;
    }
  }
  return true;
}

function isAnagram(str1, str2){
  return sameFrequency(str1.split(''), str2.split(''));
}

 console.log(sameFrequency([1, 2, 3, 4], [1, 2, 3])); // false
 console.log(sameFrequency([1, 2, 3, 4], [1, 2, 3, 4])); // true

 // congruency: a is like b given b == a*a
 console.log(sameFrequency([1, 2, 3, 4],  
                           [1, 4, 9, 16], 
                           v=>v*v)); // true
 console.log(sameFrequency([1, 2, 3, 4],  
                           [1, 4, 9, 25], 
                           v=>v*v)); // false
 
 console.log(isAnagram("", "")) // true
 console.log(isAnagram("aaz", "zza")) // false
 console.log(isAnagram("anagram", "nagaram")) // true
 console.log(isAnagram("rat", "car")) // false
 console.log(isAnagram("qwerty", "qeywrt")) // true
 console.log(isAnagram("texttwisttime", "timetwisttext")) // true
                         

  </script>
</body>
</html>
